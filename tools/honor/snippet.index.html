<!-- {"title": "Honor Calculator", "rel": "../../", "header": false} -->
<script>
// LIB
function get(id) {
  return document.getElementById(id)
}
function setText(id, text) {
  get(id).textContent = text
}
function round2dec(num) {
  return Number(num.toFixed(2))
}
// END LIB

// HONOR LIB
const BREAK_PTS = [0.003 // r14 as of v1.12
, 0.008
, 0.020
, 0.035
, 0.060 // r10
, 0.100
, 0.159
, 0.228 // r7
, 0.327
, 0.436
, 0.566 // r4
, 0.697
, 0.845
, 1.0
]
const REF_WEEK = [ 13000.0 // top CP score gets top RP score
, 12000.0  // breakpoint 14
, 11000.0
, 10000.0
,  9000.0
,  8000.0
,  7000.0  // breakpoint 9
,  6000.0
,  5000.0
,  4000.0
,  3000.0
,  2000.0  // breakpoint 4
,  1000.0
,   400.0
,     0.0 // bottom end point
]
function rank2rp(rank) {
    var _rank   = Math.floor(rank)
    if (rank >= 3.0) {
        return (rank - 2.0) * 5000.0
    } else if (rank >= 2.0) {
        return 2000 + (rank - 2.0) * 3000
    }
    return 0.0
}
function rp2rank(rp) {
    if (rp >= 5000.0) {
        return rp / (5000.0) + 2.0
    } else if (rp >= (2000.0)) {
        return 2.0
    }
    return 1.0
}
function delta(rp, gain) {
    var decay = Math.floor(Math.round(rp * 0.2))
    var diff = gain - decay
    if (diff < 0) {
        diff /= 2.0
    }
    if (diff < -2500) {
        diff = -2500
    }
    return diff
}
function groups(players) {
    return BREAK_PTS.map(break_pt => Math.floor(Math.round(break_pt * players)))
}
function bracket(standing, groups) {
    var brkt = 1.0
    var upperBound = 1.0
    var lowerBound = 1.0
    for (i = 0; i < groups.length; ++i) {
        var grp = groups[i]
        if (standing <= grp) {
            lowerBound = grp
            break;
        }
        upperBound = Number(grp) + 1.0
        brkt += 1.0
    }
    return {
        'number': brkt,
        'rankCutoff': Number(14.0 - brkt + 1.0),
        'upperSt': upperBound,
        'lowerSt': lowerBound,
        'players': lowerBound - upperBound + 1.0,
        'upperRp': REF_WEEK[brkt - 1],
        'lowerRp': REF_WEEK[brkt]
    }
}
function estimate(parameters) {
    const CALC_RP = rank2rp(parameters.rank)
    const grps = groups(parameters.players)
    const brkt = bracket(parameters.standing, grps)
    const standingRelativeToBracket = (brkt.lowerSt - parameters.standing + 1.0) / brkt.players

    const RP_GAIN_ESTIMATE = (brkt.upperRp - brkt.lowerRp) * standingRelativeToBracket + brkt.lowerRp
    const DELTA = delta(CALC_RP, RP_GAIN_ESTIMATE)
    const RP_AFTER_GAIN_ESTIMATE = CALC_RP + DELTA
    const RANK_ESTIMATE = round2dec(rp2rank(RP_AFTER_GAIN_ESTIMATE))

    const MAX_DELTA = delta(CALC_RP, brkt.upperRp)
    const MIN_DELTA = delta(CALC_RP, brkt.lowerRp)
    const RP_AFTER_MAX_GAIN = CALC_RP + MAX_DELTA
    const RP_AFTER_MIN_GAIN = CALC_RP + MIN_DELTA
    const MAX_RANK_AFTER_UPDATE = round2dec(rp2rank(RP_AFTER_MAX_GAIN))
    const MIN_RANK_AFTER_UPDATE = round2dec(rp2rank(RP_AFTER_MIN_GAIN))

    return {
        'parameters': parameters,
        'RP': CALC_RP,
        'groups': grps,
        'bracket': brkt,
        'delta': DELTA,
        'minDelta': MIN_DELTA,
        'maxDelta': MAX_DELTA,
        'newRP': RP_AFTER_GAIN_ESTIMATE,
        'newRank': RANK_ESTIMATE,
        'minNewRP': RP_AFTER_MIN_GAIN,
        'maxNewRP': RP_AFTER_MAX_GAIN,
        'minNewRank': MIN_RANK_AFTER_UPDATE,
        'maxNewRank': MAX_RANK_AFTER_UPDATE
    }
}
function render_projection(estimation) {
    const bracketNr = estimation.bracket.number
    let projection = []
    let weeks = 0
    let rank = 0
    let newEstimation = estimation
    projection.push(`Current week: going from ${estimation.parameters.rank} to ${estimation.newRank}`)
    do {
        rank = newEstimation.newRank
        newEstimation = estimate({'rank': rank, 'standing': estimation.parameters.standing, 'players': estimation.parameters.players})
        weeks++
        projection.push(`${weeks} ${(weeks > 1) ? 'weeks' : 'week'} after current: going from ${rank} to ${newEstimation.newRank}`)
    } while (newEstimation.newRank < 14.0
                && newEstimation.newRank > rank
                && Math.floor(newEstimation.newRank) < estimation.bracket.rankCutoff)
    return projection
}
function render_groups(groups) {
    rank = 14
    return groups.map((group, idx) =>
    `Top ${group} standing is bracket ${idx + 1}, gaining ${REF_WEEK[idx+1]} - ${REF_WEEK[idx]} RP (r${rank - idx} cutoff)`)
}
// END HONOR LIB
</script>

<noscript><div class="card error fluid">Please activate Javascript to use this site!</div></noscript>

<h1>WoW Classic Honor Calculator</h1>

<p>
Estimates based on your current <code>rank</code> (default <code>7.0</code>), your estimated <code>standing</code> (default <code>100</code>) and an estimate for the total number of <code>players</code> (default <code>2000</code>).
All parameters are passed as URL parameters, like this:
</p>

<pre>https://www.vanillawar.com/tools/honor/?rank=9.40&amp;standing=50&amp;players=1500</pre>

<p>
A <code>rank</code> of <code>9.4</code> means that you are rank 9 and 40% progressed towards rank 10.
</p>

    <h3>Results</h3>

    <textarea id="brackets_list" style="width:100%;font-family:monospace;">
    </textarea>

<script type="text/javascript">
function getParameters() {
    const url = new URL(window.location.href)
    let parameters = {
    'rank' : Number(url.searchParams.get('rank') || 7.0),
    'standing' : Number(url.searchParams.get('standing') || 100.0),
    'players' : Number(url.searchParams.get('players') || 2000.0),
    }
    if (parameters.standing > parameters.players) { parameters.standing = parameters.players }
    if (parameters.standing < 1) { parameters.standing = 1 }
    return parameters
}

const PARAMETERS = getParameters()
const estimation = estimate(PARAMETERS)
const projection = render_projection(estimation)

get('brackets_list').value = `Currently rank ${round2dec(PARAMETERS.rank)} (${round2dec(estimation.RP)} RP)\n`
get('brackets_list').value += `With your estimated standing of ${PARAMETERS.standing} of ${PARAMETERS.players} players, you will be in bracket: ${estimation.bracket.number}\n`
get('brackets_list').value += `Gaining between ${estimation.bracket.lowerRp} and ${estimation.bracket.upperRp} RP, estimating RP delta of ${round2dec(estimation.delta)}\n`
get('brackets_list').value += `Reaching between r${estimation.minNewRank} and r${estimation.maxNewRank}, estimating rank ${estimation.newRank} (${round2dec(estimation.newRP)} RP)\n`
get('brackets_list').value += `\n`
get('brackets_list').value += `Brackets:\n`
get('brackets_list').value += render_groups(estimation.groups.slice(0, 8)).join('\n')
get('brackets_list').value += `\n\n`
get('brackets_list').value += `Projected estimation (for standing ${PARAMETERS.standing} at ${PARAMETERS.players} players):\n`
get('brackets_list').value += projection.join('\n')
get('brackets_list').style.height = get('brackets_list').scrollHeight + 5 + "px"
</script>

<p>
    <small>Disclaimer:<br>
        The calculator is not intended for lower ranks.
        The RP/rank gain estimation is more accurate the closer you are to the center of your bracket.
        The closer you are to the top of the bracket, the higher the estimation could be (meaning you will probably gain less).
        The closer you are to the bottom of the bracket, the lower the estimation could be (meaning you will probably gain more).
        It also depends on how close or far the players at the bracket borders are CP-wise:
        The greater the gap, the more gain for the bottom player(s) in the higher bracket and the less gain for the top player(s) in the lower bracket.
        The smaller the gap, the more less for the bottom player(s) in the higher bracket and the more gain for the top player(s) in the lower bracket.
        The projection is to be taken with a grain of salt, since usually the number of players and your standing are not constant.
    </small>
</p>
